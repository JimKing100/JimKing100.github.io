---
layout: post
title: How to Create an Interactive Geographic Map Using Python and Bokeh
subtitle: Interactive Data Visualization with Choropleth Maps
image: '/img/SF Map.png'
comments: true
---

If you are looking for a powerful way to visualize geographic data then you should learn to use interactive Choropleth maps. A Choropleth map represents statistical data through various shading patterns or symbols on predetermined geographic areas such as countries, states or counties. Static Choropleth maps are useful for showing one view of data, but an interactive Choropleth map is much more powerful and allows the user to select the data they prefer to view. 

The interactive chart below provides details on San Francisco single family homes sales. The chart breaks down the single family home sales by Median Sales Price, Minimum Income Required, Average Sales Price, Average Sales Price Per Square Foot, Average Square Footage and Number of Sales all by neighborhood and year (10 years of data).

<iframe src="https://sf-real-estate.herokuapp.com/SF_Real_Estate_Project" width="950" height="775" style="border: none;"></iframe>

If you'd like to understand how to develop your own interactive map follow along as I step you through the process.

### A Word About the Code

All the code, data and associated files for the project can be accessed at my GitHub. The final Colab code for running on the Bokeh server can be found here. A test version of the Colab code skipping the data cleaning and wrangling steps can be found here.

### Using Python and Bokeh

After exploring several different approaches, I found the combination of Python and Bokeh to be the most straightforward and well-documented method for creating interactive maps.

Let's start with the installs and imports you will need for the graphs. Pandas, numpy and math are standard Python libraries used to clean and wrangle the data. The geopandas, json and bokeh imports are libraries needed for the mapping.

I work in Colab and needed to install fiona and geopandas.

```
!pip install fiona
!pip install geopandas
```
### Imports

```
# Import libraries
import pandas as pd
import numpy as np
import math

import geopandas
import json

from bokeh.io import output_notebook, show, output_file
from bokeh.plotting import figure
from bokeh.models import GeoJSONDataSource, LinearColorMapper, ColorBar, NumeralTickFormatter
from bokeh.palettes import brewer

from bokeh.io.doc import curdoc
from bokeh.models import Slider, HoverTool, Select
from bokeh.layouts import widgetbox, row, column
```

### Data Loading, Cleaning and Wrangling

As the focus of this article is on the creation of interactive maps, I will briefly describe the steps used to load, clean and wrangle the data. You can view the full cleaning and wrangling here if you are interested.

Since I have a real estate license I have access to the San Francisco MLS which I used to download 10 years (2009–2018) of single-family home sales data by neighborhood into the sf_data dataframe.

An important piece of data, house square footage, was zero for about 16% of the data. A reasonable approach to filling the data is to use the average house square footage by bedroom for all single family homes in San Francisco. For example, all one bedroom homes with zero values were filled with the average square footage of all one bedroom home sales in San Francisco.

A key column of the data is the neighborhood code which needs to match the mapping code for the neighborhood. This will allow us to merge the data with the map. A dictionary is used to change the neighborhood codes in the data to match the neighborhood codes in the map.

Finally a year and price per square foot column are added to sf_data and the sf_data is summarized using groupby and aggregate functions to create the final neighborhood_data dataframe with all numeric fields converted to integer values for ease in displaying the data:

#### neighborhood_data DataFrame

![neighborhood_data DataFrame](/img/Neighborhood_Data.png)

The neighborhood_data dataframe repesents the single-family home sales by year summarized by neighborhood. Now we need to map this data onto a San Francisco neighborhood map.

Here's a shortcut to the cleaned data:

```
neighborhood_data = pd.read_csv('https://raw.githubusercontent.com/JimKing100/SF_Real_Estate_Live/master/data/neighborhood_data.csv')
```

### Prepare the Mapping Data and GeoDataFrame

Bokeh offers several ways to work with geographical data including Tile Provider Maps, Google Maps and GeoJSON data. We will be working with GeoJSON, a popular open standard for representing geographical features with JSON. JSON (JavaScript Object Notation), is a minimal, readable format for structuring data. Bokeh uses JSON to transmit data between a bokeh server and a web application.

In a typical Bokeh interactive graph the data source needs to be a ColumnDataSource - this is a key concept in Bokeh. However, when using a map you use a GeoJSONDataSource instead.

To make our work with geospatial data in Python easier we use GeoPandas. It combines the capabilities of pandas and shapely, providing geospatial operations in pandas and a high-level interface to multiple geometries to shapely. We will use GeoPandas to create a GeoDataFrame - a precursor to creating the GeoJSONDataSource.

Finally, we need a map that is in geojson format. San Francisco, through their DataSF web site, has an exportable neighborhood map in geojson format.

Let's walk through the following code to show how a GeoDataFrame is created.

```
# Read the geojson map file for Realtor Neighborhoods into a GeoDataframe object
sf = geopandas.read_file('https://raw.githubusercontent.com/JimKing100/SF_Real_Estate_Live/master/data/Realtor%20Neighborhoods.geojson')

# Set the Coordinate Referance System (crs) for projections
# ESPG code 4326 is also referred to as WGS84 lat-long projection
sf.crs = {'init': 'epsg:4326'}

# Rename columns in geojson map file
sf = sf.rename(columns={'geometry': 'geometry','nbrhood':'neighborhood_name', 'nid': 'subdist_no'}).set_geometry('geometry')

# Change neighborhood id (subdist_no) for correct code for Mount Davidson Manor and for parks
sf.loc[sf['neighborhood_name'] == 'Mount Davidson Manor', 'subdist_no'] = '4n'
sf.loc[sf['neighborhood_name'] == 'Golden Gate Park', 'subdist_no'] = '12a'
sf.loc[sf['neighborhood_name'] == 'Presidio', 'subdist_no'] = '12b'
sf.loc[sf['neighborhood_name'] == 'Lincoln Park', 'subdist_no'] = '12c'

sf.sort_values(by=['subdist_no'])
```

We use geopandas to read the geojson map into the GeoDataFrame sf. We then set the coordinate reference system to lat-long projection. Next, we rename several columns and use set_geometry to set the GeoDataFrame to column 'geometry' containing the active geometry (the description of the shapes to draw). Finally, we clean up some neighborhood id's to match neighborhood_data.

![sf GeoDataFrame](/img/GeoDataFrame.png)


