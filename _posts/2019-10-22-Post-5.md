---
layout: post
title: Data Visualization - Advanced Bokeh Techniques
subtitle: Bokeh Interactive Maps, DataTables, TextInput, Document Layout and Debugging
image: '/img/SF Map.png'
comments: true
published: false
---

If you are looking to create powerful data visualizations then you should consider using Bokeh.  In an earlier article, I demonstrated how to create an interactive geographic map using Bokeh ([Click here][1]).  This article will take it a step further and demonstrate how to use an interactive map with a data table and text fields organized using a Bokeh layout to create an interactive dashboard for displaying data.  I will also demonstrate several methods for debugging the code which also provides some insight into the structures used in Bokeh.

First, let's take a look at the finished product which appeared in the article "[Look Out Zillow Here Comes Jestimate!][2]":

<iframe src="https://sf-real-estate.herokuapp.com/SF_Real_Estate_Project" width="950" height="775" style="border: none;"></iframe>

If you'd like to understand how to develop a similar visualization follow along as I step you through the process.

### A Word About the Code

All the code, data and associated files for the project can be accessed at my [GitHub][3].  The project is separated into two Colab notebooks.  One runs the linear regression model (creating the data for the visualization) and the other produces the interactive visualization using a Bokeh server on Heroku.

### Installs and Imports

Let's start with the installs and imports you will need for the graphs. Pandas, numpy and math are standard Python libraries used to clean and wrangle the data. The geopandas, json and bokeh imports are libraries needed for the mapping.

I work in Colab and needed to install fiona and geopandas.  While you are developing the application in Colab, you will need to keep these installs in the code.  However, once you start testing with the Bokeh server you will need to comment out these installs as Bokeh chokes on the magic commands (!pip install...).

```
# Install fiona - need to comment out for transfer to live site.
# Turn on for running in a notebook
%%capture
!pip install fiona

# Install geopandas - need to comment out for tranfer to live site.
# Turn on for running in a notebook
%%capture
!pip install geopandas
```

```
# Import libraries
import pandas as pd
import numpy as np
import math

import geopandas
import json

from bokeh.io import output_notebook, show, output_file
from bokeh.plotting import figure
from bokeh.models import GeoJSONDataSource, LinearColorMapper, ColorBar, NumeralTickFormatter
from bokeh.palettes import brewer

from bokeh.io.doc import curdoc
from bokeh.models import Slider, HoverTool, Select, TapTool, CustomJS, ColumnDataSource, TableColumn, DataTable, CDSView, GroupFilter
from bokeh.layouts import widgetbox, row, column, gridplot
from bokeh.models.widgets import TextInput
```

### Preliminary Code

As the focus of this article is on the creation of interactive dashboard, I will skip the following steps which are covered in detail in my previous article ([Click here][1]).

1. Preparing the Mapping Data and GeoDataFrame - geopandas.read_file()
2. Create the Colorbar Lookup Table - format_df dataframe
3. Creating the JSON Data for the GeoJSONDataSource - json_data function 
4. Creating a Plotting Function - make_plot function
5. The Color Bar - ColorBar, part of make_plot function
6. The Hover Tool - HoverTool

### Data Loading, Cleaning and Wrangling

I will briefly discuss the data used in the application, you can view the full cleaning and wrangling [here][4] if you are interested.

There are two dataframes of data used in the application:  neighborhood data used to show aggregate statistics for 2018 for each neighborhood and display data for each individual property sold in 2018 produced by the linear regression code in my article "[Look Out Zillow Here Comes Jestimate!][2]"

#### neighborhood_data DataFrame

![neighborhood_data DataFrame](/img/jestimate/neighborhood_data.png)

#### display_data DataFrame

![display_data DataFrame](/img/jestimate/display_data.png)

### Main Code for Application

Let's take a look at the main code for the application and then step through it in detail.

```
### Start of Main Program
    
# Input geojson source that contains features for plotting for:
# initial year 2018 and initial criteria sale_price_median
geosource = GeoJSONDataSource(geojson = json_data(2018))
original_geosource = geosource
input_field = 'sale_price_mean'

# Initialize the datatable - set datatable source, set intial neighborhood, set initial view by neighborhhood, set columns
source = ColumnDataSource(results_data)
hood = 'Bernal Heights'
subdist = '9a'
view1 = CDSView(source=source, filters=[GroupFilter(column_name='subdist_no', group=subdist)])
columns = [TableColumn(field = 'full_address', title = 'Address')]

# Define a sequential multi-hue color palette.
palette = brewer['Blues'][8]

# Reverse color order so that dark blue is highest obesity.
palette = palette[::-1]

#Add hover tool to view neighborhood stats
hover = HoverTool(tooltips = [ ('Neighborhood','@neighborhood_name'),
                               ('# Sales', '@sale_price_count'),
                               ('Average Price', '$@sale_price_mean{,}'),
                               ('Median Price', '$@sale_price_median{,}'),
                               ('Average SF', '@sf_mean{,}'),
                               ('Price/SF ', '$@price_sf_mean{,}'),
                               ('Income Needed', '$@min_income{,}')])

# Add tap tool to select neighborhood on map
tap = TapTool()

# Call the plotting function
p = make_plot(input_field)

# Load the datatable, neighborhood, address, actual price, predicted price and difference for display
data_table = DataTable(source = source, view = view1, columns = columns, width = 280, height = 280, editable = False)
tap_neighborhood = TextInput(value = hood, title = 'Neighborhood')
table_address = TextInput(value = '', title = 'Address')
table_actual = TextInput(value = '', title = 'Actual Sale Price')
table_predicted = TextInput(value = '', title = 'Predicted Sale Price')
table_diff = TextInput(value = '', title = 'Difference')
table_percent = TextInput(value = '', title = 'Error Percentage')
table_shap = TextInput(value = '', title = 'Impact Features (SHAP Values)')

# On change of source (datatable selection by mouse-click) fill the line items with values by property address
source.selected.on_change('indices', function_source)

# On change of geosource (neighborhood selection by mouse-click) fill the datatable with nieghborhood sales
geosource.selected.on_change('indices', function_geosource)

# Layout the components with the plot in row postion (0) and the other components in a column in row position (1)
layout = row(column(p, table_shap), column(tap_neighborhood, data_table, table_address,
              table_actual, table_predicted, table_diff, table_percent))

# Add the layout to the current document
curdoc().add_root(layout)

# Use the following code to test in a notebook
# Interactive features will not show in notebook
#output_notebook()
#show(p)
```

### Step 1 - Initialize the Data

Bokeh offers several ways to work with data.  In a typical Bokeh interactive graph the data source is a ColumnDataSource. This is a key concept in Bokeh. However, when using a map we use a GeoJSONDataSource.  We will be using both!

```
# Input geojson source that contains features for plotting for:
# initial year 2018 and initial criteria sale_price_median
geosource = GeoJSONDataSource(geojson = json_data(2018))
original_geosource = geosource
input_field = 'sale_price_mean'

# Initialize the datatable - set datatable source, set intial neighborhood, set initial view by neighborhhood, set columns
source = ColumnDataSource(results_data)
hood = 'Bernal Heights'
subdist = '9a'
view1 = CDSView(source=source, filters=[GroupFilter(column_name='subdist_no', group=subdist)])
columns = [TableColumn(field = 'full_address', title = 'Address')]
```

We pass the json_data function the year of data we would like loaded (2018). The json_data function then pulls the data from **neighborhood_data** for the selected year and merges it with the mapping data returning the merged file converted into JSON format for the Bokeh server.  Our GeoJSONDataSource is geosource.

Our ColumnDataSource, source, is initialized with the **results_data** and a Column Data Source View (CDSView), view1, is initialized with the Bernal Heights neighborhood (subdist=9a).  CDSView is a method for filtering data allowing you to show a subset of the data, in this case the Bernal Heights neighborhood.  The column of the datatable is initialized with the full address of the property.






*This is Part of a Series of Articles Exploring San Francisco Real Estate Data*

*San Francisco Real Estate Data Source:  San Francisco MLS, 2009-2018 Data*

[1]: <https://towardsdatascience.com/how-to-create-an-interactive-geographic-map-using-python-and-bokeh-12981ca0b567> 
[2]: <https://medium.com/p/look-out-zillow-here-comes-jestimate-145a96efbfbb?source=email-607257182a94--writer.postDistributed&sk=c7ba752420820a3ef1b8b7cabf535b47> 
[3]: <https://github.com/JimKing100/Jestimate_Live> 
[4]: <https://github.com/JimKing100/Jestimate_Live/blob/master/Final_SF_Map_Code.ipynb> 




